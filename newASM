32 storage regs
64k instructions
128k memory / 64k words

interrupt               interact with OS
                        TBD
halt                    exit
enable.interrupts
disable.interrupts

push.immed              next 2 instruction values will be pushed
load                    pops address, pushesh value
store                   pops value and address, stores at value
save                    saves regs and return address
return                  restores
push.R                  pushes reg
pop.R                   pops into reg
pop                     kill top value

add                     add top two values and push result
sub
mul
mod
div

inc.R                   increment register
dec.R                   decrement register
mask.R                  AND a register and top value and push result
sh.R                    shift register l/r by amount in top value of stack
rol.R                   roll register l/r by amount in top value of stack

and                     bitwise and
ior                     bitwise or
xor                     bitwise xor
not                     logical negation
neg                     bitwise negation

compare.signed          pushes 0 if top value is less than next (signed)
compare.unsigned        pushes 1 if top value is greatest (unsigned)

jump                    unconditional jump to address in top register
jump.ifzero             jump if top value is 0

switch((*opcode >> 5) & 0x7) {
    case 0x0:
        further_decode(opcode);
        break;
    case 0x1:
        register_mask(opcode & 0x1F);
        break;
    case 0x2:
        register_sh(opcode & 0x1F);
        break;
    case 0x3;
        register_rol(opcode & 0x1F);
        break;
    case 0x4;
        register_push(opcode & 0x1F);
        break;
    case 0x5;
        pop_register(opcode & 0x1F);
        break;
    case 0x6;
        register_inc(opcode & 0x1F);
        break;
    case 0x7;
        register_dec(opcode & 0x1F);
        break;
}

switch(*opcode) {
    default:
    case 0x00:
        break;
    case 0x01:
        interrupt();
        break;
    case 0x02:
        enable_interrupts();
        break;
    case 0x03:
        disable_interrupts();
        break;
    case 0x04:
        vswap();
        break;
    case 0x05:
        push_immed();
        break;
    case 0x06:
        save();
        break;
    case 0x07:
        return();
        break;
    case 0x08:
        load();
        break;
    case 0x09:
        store();
        break;
    case 0x0A:
        add();
        break;
    case 0x0B:
        sub();
        break;
    case 0x0C:
        mul();
        break;
    case 0x0D:
        mod();
        break;
    case 0x0E:
        div();
        break;
    case 0x10:
        and();
        break;
    case 0x11:
        ior();
        break;
    case 0x12:
        xor();
        break;
    case 0x13:
        not();
        break;
    case 0x17:
        neg();
        break;
    case 0x18:
        compare_signed();
        break;
    case 0x19:
        compare_unsigned();
        break;
    case 0x1E:
        jump();
        break;
    case 0x1F:
        jump_ifzero();
        break;
}

void add()
{
    short a = pop();
    short b = pop();
    push(a + b);
}

void push_immed()
{
    push((opcode[1] << 8) | opcode[2]);
    opcode += 2;
}

void jump_ifzero()
{
    short addr = pop();
    short cond = pop();

    if(!cond) regs[IP] = addr;
}

void compare()
{
    short b = pop();
    short a = pop();

    push(b > a);
}

void compare_unsigned()
{
    unsigned short b = pop();
    unsigned short a = pop();

    push(b > a);
}

void register_push(size_t reg)
{
    push(regs[reg]);
}

void pop_register(size_t reg)
{
    regs[reg] = pop();
}

void register_mask(size_t reg)
{
    unsigned short mask = pop();
    unsigned short val = regs[reg];
    push(mask & val);
}

struct {
#define IP 8
    short regs[9];
    short data[0x1FFFF];
    short code[0xFFFF];
} machine;
// alt
//short data[48 * 1024 * sizeof(short) - 1];



assembler:
assemble()
{
    mode = DATA;
    while(!EOF) {
        switch(mode) {
        case DATA:
            for_data();
            break;
        case CODE:
            for_code();
            break;
        default: error();
        }
    }
}

for_data()
{
    while(!EOF) {
        char const* name = getToken();
        if(name[0] == '.') {
            switch_mode(name);
            return;
        }
        add_label_to_definitions(name);
        char const* ssize = getToken();
        long size = atol(ssize);

        getToken/translate/add until size matched or error
    }
}

for_code()
{
    while(!EOF) {
        char const* token = getToken();
        switch(token[0]) {
        case '.':
            switch_mode(token);
            break;
        case ':':
            add_label_to_definitions(token);
            continue;
        case 'A':
            switch(token[1]) {
            case 'D':
                produce(0xA);
                continue;
            case 'N':
                produce(0x10);
                continue;
            default: error();
            }
        case 'C':
            switch(token[1]) {
            case 'S':
                produce(0x18);
                continue;
            case 'U':
                produce(0x19);
                continue;
            default: error();
            }
        case 'D':
            switch(token[1]) {
            case 'I':
                produce(0x3);
                continue;
            case 'V':
                produce(0xE);
                continue;
            default: error();
            }
        case 'E':
            switch(token[1]) {
            case 'I':
                produce(0x2);
                continue;
            default: error();
            }
        case 'I':
            switch(token[1]) {
            case 'N':
                produce(0x1);
                continue;
            default: error();
            }
        case 'J':
            switch(token[1]) {
            case 'P':
                produce(0x1E);
                continue;
            case 'Z':
                produce(0x1F);
                continue;
            default: error();
            }
        case 'L':
            switch(token[1]) {
            case 'D':
                produce(0x8);
                continue;
            default: error();
            }
        case 'M':
            switch(token[1]) {
            case 'O':
                produce(0xD);
                continue;
            case 'U':
                produce(0xC);
                continue;
            default: error();
            }
        case 'N':
            switch(token[1]) {
            case 'E':
                produce(0x17);
                continue;
            case 'O':
                produce(0);
                continue;
            case 'T':
                produce(0x13);
                continue;
            default: error();
            }
        case 'O':
            switch(token[1]) {
            case 'R':
                produce(0x11);
                continue;
            default: error();
            }
        case 'P':
            switch(token[1]) {
            case 'I':
                push_imed();
                continue;
            case 'R':
                if(token[2] != '.') error();
                produce_reg(0x5, token + 3);
                continue;
            default: error();
            }
        case 'R':
            switch(token[1]) {
            case 'D':
            case 'I':
            case 'L':
            case 'M':
            case 'P':
            case 'R':
            case 'T':
            default: error();
            }
        case 'S':
            switch(token[1]) {
            case 'T':
            case 'U':
            case 'V':
            default: error();
            }
        case 'X':
            switch(token[1]) {
            case 'R':
                END(token, 2);
                produce(0x12);
                continue;
            default: error();
            }
        }
    }
}

#define END(X, N) if(X[N] != '\0') error();

produce_reg(unsigned char code, char const* token)
{
    switch(token[3]) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7': {
            unsigned char reg = 0x1F & (token[3] - '0');
            unsigned char opcode = code << 5;
            unsigned char i = opcode | reg;
            produce(i);
            break; }
        default: error();
    }
}

void produce(unsigned char c)
{
    fwrite(&c, 1, 1, fout);
    current_size++;
}

void push_imed()
{
    char const* token = getToken();
    produce(0x5);
    if(token[0] == ':') {
        add_label_used_at(current_size + 1, token);
        produce(0);
        produce(0);
    }

    char* endptr;
    long num = strtol(token, &endptr, 0);
    if(endptr) error();
    produce(num & 0xFF);
    num >>= 8;
    produce(num & 0xFF);
}

std::map<std::string, size_t> label_usages;
std::map<size_t, std::string> label_definitions;

void add_label_to_definitions(char const* token)
{
    label_definitions.insert(std::make_pair(std::string(token), current_size));
}

void add_label_used_at(size_t size, char const* token)
{
    label_usages.insert(std::make_pair(size, std::string(token)));
}

void resolve_labels()
{
    std::for_each(label_usages.begin(), label_usages.end(), [&](label_usages::value_type const& lbl){
        fseek(fout, lbl.first, SEEK_SET);
        auto found = label_definitions.find(lbl.second);
        if(found == label_definitions.end()) error();
        fwrite(&found->second, sizeof(size_t), 1, fout);
    });
}
